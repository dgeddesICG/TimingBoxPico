// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// -------------- //
// triggerControl //
// -------------- //

#define triggerControl_wrap_target 0
#define triggerControl_wrap 6
#define triggerControl_pio_version 0

static const uint16_t triggerControl_program_instructions[] = {
            //     .wrap_target
    0x80a0, //  0: pull   block
    0x6004, //  1: out    pins, 4
    0x6064, //  2: out    null, 4
    0xa027, //  3: mov    x, osr
    0x0044, //  4: jmp    x--, 4
    0x0026, //  5: jmp    !x, 6
    0xe000, //  6: set    pins, 0
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program triggerControl_program = {
    .instructions = triggerControl_program_instructions,
    .length = 7,
    .origin = -1,
    .pio_version = triggerControl_pio_version,
#if PICO_PIO_VERSION > 0
    .used_gpio_ranges = 0x0
#endif
};

static inline pio_sm_config triggerControl_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + triggerControl_wrap_target, offset + triggerControl_wrap);
    return c;
}

// helper function for the triggerControl.pio program
    static inline void triggerControl_program_init(PIO pio, uint sm, uint offset, uint pin, uint32_t clkDivisorFP)
    {
        // configure the sm using standard config
        pio_sm_config config = triggerControl_program_get_default_config(offset);
        // map the set and out pin group "pins" to the correct bank of GPIOs.
        // pins need to have consecutive addresses. Otherwise us sm_config_set_set_pins_mask???
        sm_config_set_set_pins(&config, pin, 4);
        sm_config_set_out_pins(&config, pin, 4);
        // set clock divider
        // clock divider is 16:8 Fixed Point integer
        uint16_t clkDivisorINT = (clkDivisorFP >> 8) & 0xFFFF;
        uint8_t clkDivisorFRAC = clkDivisorFP & 0xFF;
        sm_config_set_clkdiv_int_frac8(&config, clkDivisorINT, clkDivisorFRAC);
        // tell the PIO which GPIO pins itll be talking to
        for (int i = 0; i < 5; i++)
        {
            pio_gpio_init(pio, pin + i);
        }
        // set the pin directions - true for output, false for input
        pio_sm_set_consecutive_pindirs(pio, sm, pin, 4, true);
        // load config into the state machine and jump to start of program
        pio_sm_init(pio, sm, offset, &config);
        // sm is enabled in the main C code
    }

#endif

